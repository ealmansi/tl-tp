\newpage
\section{Resolución y aclaraciones}
\subsection{Generalidades}

Para la resolución del problema planteado se decidió utilizar dos de las herramientas propuestas en clase. El analizador léxico $\bold{Flex}$ se utilizó para especificar los tokens del lenguaje MyLanga, generando un \emph{scanner} que transforma el código a procesar en un stream de tokens. Estos tokens pasan a ser los terminales de la gramática que se utiliza para describir con precisión el lenguaje, a partir de la cual el generador de parsers $\bold{Bison}$ construye un parser para MyLanga.

La definición de la gramática que se provee como entrada a $\bold{Bison}$, asociando a cada producción una regla semántica, la cual genera la lógica necesaria para construir el árbol de sintaxis, o \emph{AST}, que representa el programa procesado.

De esta forma, el intérprete de MyLanga desarrollado utiliza el parser generado de forma automática, y posteriormente ejecuta el código codificado en el \emph{AST}.
\newline

Algunas aclaraciones de la implementación:

\begin{itemize}
  \item Además de los nodos del árbol que representan un grupo de funciones, una instrucción, un if, etc, hay un objeto global que contiene la información contextual del programa, cumpliendo un propósito doble: por un lado, contiene un diccionario con las funciones definidas en el programa, y por el otro, se encarga de generar los scopes durante la ejecución. El mismo se comporta como un stack y se utiliza para saber que variables son visibles tanto a la hora de parsear como ejecutar el código. Cuando se realza un llamado a función, se pushea un estado nuevo al stack dejando vacía la definición de variables (excepto por los parámetros si hay alguno). Una vez que se retorna de la función, se popea el stack para volver al estado inicial del llamador.
  \item Una vez generado el \emph{AST}, se realiza un proceso de verificación de validez sobre el programa. El mismo consiste en recorrer recursivamente el árbol, evaluando en cada nodo si este es válido, así como también sus hijos. El procedimiento se propaga independientemente de si se encuentra efectivamente algún error, permitiendo detectar múltiples problemas en una única pasada. Posteriormente, bajo la condición de que todos los nodos del árbol verificaran su condición de validez, se procede a ejecutar el comado plot.
  \item Se agregó la compatibilidad con código que hace recursión explícita. Esto se logró definiendo una función inmediatamente luego de leer su signatura, previo a evaluar la validez de su bloque de código correspondiente. Naturalmente, si se encuentra algún error en el cuerpo de la función, se elimina la misma de la tabla de contexto, generando posiblemente una serie de errores en el resto del programa donde la misma sea utilizada.
\end{itemize}

\subsection{Requisitos y modos de uso}


\begin{itemize}
  \item La implementación requiere tener instaladas las herramientas \emph{Flex} y \emph{Bison}.
  \item La implementación del AST fue escrita en C++ standard 11. En el caso de usar g++, el mismo debe ser versión 4.7 o superior, para soportar la directiva -std=c++11. No es compatible con el std c++0x.
  \item El script mylanga\_plot.sh grafica un archivo mylanga mediante la siguiente sintaxis: 
	
	./mylanga\_plot.sh programa.my salida.png
	
	Ejemplo: ./mylanga\_plot.sh circulo.my circulo.png
	\item También se proveen los scripts correr-tests-correctos.sh y correr-tests-errores.sh para automatizar la corrida de los tests provistos por la cátedra.
\end{itemize}